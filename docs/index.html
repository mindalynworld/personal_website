<html>
    <head>
        <title>Mindy Ng</title>
        <link rel="stylesheet" href="styles.css">
        <meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
    </head>
    <body>
        <div class="header" width="100%" height="300">
            <svg width="300" height="270">
                <g>
                    <circle class="logo-circle" id="technology"
                    cx="110" cy="180" r="60"
                    fill="rgba(255, 199, 100, 0.75)"
                    />
                    <circle class="logo-circle" id="education"
                    cx="190" cy="180" r="60"
                    fill="rgba(205, 232, 181, 0.75)"
                    />
                    <circle class="logo-circle" id="arts"
                    cx="150" cy="130" r="60"
                    fill="rgba(195, 175, 252, 0.75)" 
                    />
                    <text x="75" y="170" 
                    font-size="35" font-weight="500"
                    fill="white">Mindy Ng</text>
                </g>
            </svg>
            <p class="tagline">A freelance data visualization engineer, STEAM educator, and professional dancer based in the Bay Area, California.</p>
        </div>

        <div class="wrapper">
            <div id="viz-container" class="viz-container">
                <p class="viz-title">Experience Timeline</p>
                <!-- <div class="legend-item" id="description">
                    
                </div> -->

                <!-- <div class="legend-item" id="description"> </div> -->
                <div class="legend" id="timeline">
                    <div class="legend-item" id="category">
                        <p class="legend-title">Category</p>
                        <svg class="svg-category" width="175" height="70" preserveAspectRatio="xMinYMin meet" viewbox="0 0 175 70">
                            <!-- eventually make title svg so it can size dynamically -->
                            <circle class="legend-symbol" cx="18" cy="8" r="7" fill="rgba(255, 199, 100, 0.75)"></circle>
                                <text class="legend-text" x="30" y="13">Technology & Data</text>
                            <circle class="legend-symbol" cx="18" cy="28" r="7" fill="rgba(205, 232, 181, 0.75)"></circle>
                                <text class="legend-text" x="30" y="33">Education & Community Building</text>
                            <circle class="legend-symbol" cx="18" cy="48" r="7" fill="rgba(195, 175, 252, 0.75)"></circle>
                                <text class="legend-text" x="30" y="53">Arts & Storytelling</text>
                        </svg>
                    </div>
                    <div class="legend-item" id="time-commitment">
                        <h4 class="legend-title">Time Commitment</h4>
                        <svg class="svg-time-commitment" width="300" height="70" preserveAspectRatio="xMinYMin meet" viewbox="0 0 300 70">
                            <!-- eventually make title svg so it can size dynamically -->
                            <rect class="legend-symbol time" y="4" x="25" rx="5" ry="5" width="40" height="24"></rect>
                                <text class="legend-text" x="25" y="47">Full-time</text>
                                <text class="legend-text sub" x="25" y="63">(30-40+ hr/wk)</text>
                            <rect class="legend-symbol time" y="12" x="125" rx="5" ry="5" width="40" height="16"></rect>
                                <text class="legend-text" x="125" y="47">Part-time</text>
                                <text class="legend-text sub" x="125" y="63">(10-20 hr/wk)</text>
                            <rect class="legend-symbol time" y="20" x="225" rx="5" ry="5" width="40" height="8"></rect>
                                <text class="legend-text" x="225" y="47">Intermittent</text>   
                                <text class="legend-text sub" x="225" y="63">(&lt;10 hr/wk)</text>
                        </svg>
                    </div>
                </div>
                    
            </div>
            <div class="text-container">
                <div class="text-block">
                    <!-- <h3>Section Title</h3> -->
                </div>
            </div>
        </div>


    <script type="module">
        import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";
        
        let dates = [2015, 2016, 2017, 2018, 2019, 2020, 2021, 2022, 2023, 2024];

        /* COLOR DEFINITIONS (maybe this can exist in styles and just add attr class?) */
        var arts_color = "rgb(195, 175, 252)"; 
        var edu_color = "rgb(205, 232, 181)";
        var tech_color = "rgb(255, 199, 100)";
        var arts_color_faded = "rgba(195, 175, 252, 0.75)"; 
        var edu_color_faded = "rgba(205, 232, 181, 0.75)";
        var tech_color_faded = "rgba(255, 199, 100, 0.75)";
        var colors_faded = [edu_color_faded, arts_color_faded, tech_color_faded];

        var gradient_normal = `linear-gradient(to right bottom, ${arts_color},  ${edu_color}, ${tech_color})`;
        var gradient_faded = `linear-gradient(to right bottom, ${arts_color_faded}, ${edu_color_faded}, ${tech_color_faded})`;
        
        /* GLOBAL ATTRIBUTES */
        var padding = 70;
        var rect_padding = 15;
        var month_length = 10;
        var item_length = 15;
        var num_items = 22;
        var num_months = 112; //104 is original. adding more for scaling to allow for title overflow (up to dec 2024)
        var w = (num_months * month_length) + padding * 2; // + 200 is to allow for title overflow
        var h = (num_items * (item_length * 2 + rect_padding)) + padding*2;

        /* DEFINING TIMELINE SVG CANVAS */
        var wrapper = d3.select(".wrapper") // this doesn't even need to be d3
            //.attr("style", `background-image: ${gradient_normal}`);

        var timelineContainer = d3.select("div#viz-container"); // container allows svg to be dynamically sized when window is adjusted
            
        var svgTimeline = timelineContainer.insert("svg", ".legend") // inserts timeline before the legend
            .attr("preserveAspectRatio", "xMinYMin meet")
            .attr("viewBox", `0 0 ${w} ${h}`)
            .classed("svg-timeline", true)
            //.attr("style", "background-color: grey")
            // .attr("style", `background-image: ${gradient_normal}`);   
                
        var defs = svgTimeline.append("defs");

        /* FUNCTION DEFINITIONS */

        function generateRandomIndex(max, used_set) {
            var index = Math.round(Math.random() * max)
            if (used_set.has(index)) {
                if (used_set.size == num_items) {
                    return 0; // no more indices
                }
                index = generateRandomIndex(max, used_set);
            }
            used_set.add(index)
            return index;
        }

        /* LOGO PULSING TRANSITIONS */
        var recolor = function() {
            d3.selectAll(".logo-circle")
            .transition()
            .delay(function(d, i) {
                return i*500;
            })
            .duration(1000)
            .attr("fill", function(d, i) {
                return colors_faded[i]
            })
            .on("end", function() {
                var used = new Set();

                d3.selectAll("#technology")
                .transition()
                .duration(1000)
                .attr("fill", () => colors_faded[generateRandomIndex(2, used)])
                // .on("end", ()=>
                //     setTimeout(recolor, 4000)
                // );

                d3.selectAll("#education")
                .transition()
                .delay(500)
                .duration(1000)
                .attr("fill", () => colors_faded[generateRandomIndex(2, used)])

                d3.selectAll("#arts")
                .transition()
                .delay(1000)
                .duration(1000)
                .attr("fill", () => colors_faded[generateRandomIndex(2, used)])
            });
        }

        // gradient function is needed to color the svg shape elements
        function createGradient(id, color1, perc1, color2, perc2, color3=null, perc3=null) {
            var gradient = defs.append("linearGradient")
                .attr("id", id)
                .attr("y1", "0%")
                .attr("y2", "100%")
                .attr("x1", "0%")
                .attr("x2", "0%")
            
            gradient.append("stop")
                .attr('class', 'start')
                .attr("offset", perc1)
                .attr("stop-color", color1)
                .attr("stop-opacity", 1);
                
            gradient.append("stop")
                .attr('class', 'middle')
                .attr("offset", perc2)
                .attr("stop-color", color2)
                .attr("stop-opacity", 1);   

            if (color3 != null) {
                gradient.append("stop")
                .attr('class', 'end')
                .attr("offset", perc3)
                .attr("stop-color", color3)
                .attr("stop-opacity", 1);
            }
        } 

        function determineColors(d) { // update this to be more parameter based so it can cover more cases
            var solid = false;

            if (d.edu_weight == 1) {
                solid = true;
                return [solid, edu_color];
            }
            if (d.arts_weight == 1) {
                solid = true;
                return [solid, arts_color];
            }
            if (d.tech_weight == 1) {
                solid = true;
                return [solid, tech_color];
            }
            
            let gradient;
            if (d.edu_weight > 0) {
                if (d.arts_weight > 0) {
                    if (d.tech_weight > 0) {
                        gradient = "allGradient";
                        return [solid, gradient];
                    }
                    gradient = "eduArtsGradient";
                }
                else if (d.tech_weight > 0) {
                    gradient = "eduTechGradient";
                }
            } else if (d.arts_weight > 0 && d.tech_weight > 0) {
                gradient = "techArtsGradient";
            }

            return [solid, gradient];
        }

        var currTimelineSelection = null;
        var keepSelection = false;

        function clearTimelineSelection() {
            d3.selectAll('.item-group')
                .attr("opacity", 1)
                //.attr('stroke-width', 1)
        
            d3.selectAll(".item-description").remove();

            keepSelection = false
            currTimelineSelection = null;
        }

        function showTimelineItemDescription(element, data) {
            /* add text to description to text container */
            d3.select('.text-block').append("div")
                .attr("class", "item-description")            
                .html(`
                    <p style="font-weight: 600; font-size: 1.6rem">${data.title}</p>
                    <p style="font-weight: 500; font-size: 1.4rem">
                        ${data.location} <br>
                        ${data.start_date} - ${data.end_date}
                    </p>
                    <p style="margin:1rem; font-size: 1.4rem">${data.description}</p>
                `);
        }

        function fadeAll() {
            /* fade all rects and text */
            d3.selectAll('.item-group').attr("opacity", 0.5);

        }

        /* highlight item group and rect stroke */
        function highlightTimelineItem(item_group, rect) {

            var group_id = d3.select(item_group).attr("id");
            d3.selectAll("#" + group_id)
                .attr("opacity", 1);

            // var rect_id = d3.select(rect).attr("id");
            // d3.selectAll("#" + rect_id)
            //     .attr('stroke-width', 2);

            // wrapper.attr("style", `background-image: ${gradient_faded}`);


        }

        /* CALL FUNCTIONS */

        /* start logo animations */
        recolor();
        setInterval(recolor, 6000);

        d3.select(".header").selectAll("circle").on('mouseover', recolor);


        /* creating gradients for each combination of categories, used for rects and tool tips */
        var eduArtsGradient = createGradient("eduArtsGradient", edu_color, "0%", arts_color, "100%");
        var eduTechGradient = createGradient("eduTechGradient", tech_color, "0%", edu_color, "100%");
        var techArtsGradient = createGradient("techArtsGradient", arts_color, "0%", tech_color, "100%");
        var allGradient = createGradient("allGradient", arts_color, "0%", tech_color, "50%", edu_color, "100%");

        /* Loading in the experience data and rendering the timeline with d3.js */
        d3.csv("personalExperienceData.csv").then( function(data) {
            console.log(data);
            data = data.filter((item) => (item.include == 1));
            data.sort((a,b) => a.start_mo - b.start_mo)

            // var usedIndices = new Set();
            var currY = padding;
            var currY2 = padding;
            var currY3 = padding; // this works but it's JANK
            var currY4 = padding; 

            var itemGroup = svgTimeline.selectAll('g')
                .data(data)
                .enter()
                .append('g')
                .attr("class", "item-group")
                .attr('id', (d,i) => "item-group-"+i);

            itemGroup.append("rect")
                .attr("class", "experience-rect")
                .attr('id', (d,i) => "item_"+i)
                .attr("y", function(d, i) {
                    /* all random but in slots */
                    // return generateRandomIndex(num_items, usedIndices) * (item_length + padding) + padding 

                    /* in order */
                    //return i*(item_length + padding) + padding 
                    
                    /* in order but with new width sizing */
                    var temp = currY;
                    currY = currY + (item_length*d.time_level) + rect_padding;
                    return temp;

                }) 
                    // update to depend on category 
                    // i just don't really know what to do with the blended ones
                .attr("x", (d) => d.start_mo * month_length + padding)
                .attr("height", (d) => d.time_level * item_length)
                .attr("width", (d) => d.num_months * month_length)
                .attr('stroke', 'grey')
                .attr('rx', '5')
                .attr('ry', '5')
                .attr("fill", function(d) {
                    var [solid, color] = determineColors(d);

                    if (solid == true) {
                        return color;
                    } 
                    
                    return `url(#${color})`;
                })

            
            // the update happens async so it fucks it up.

            itemGroup.append("line")
                .attr('x1', function(d) {
                    if (d.start_mo < num_months / 2) {
                        return (d.start_mo * month_length + padding) + (d.num_months * month_length) + 1
                    } else {
                        return d.start_mo * month_length + padding - 40;
                    }
                    
                })
                .attr('y1', function(d)  {
                    var temp = currY2;
                    currY2 = currY2 + (item_length*d.time_level) + rect_padding;
                    return temp + (d.time_level * item_length)/2
                })
                .attr('x2', function(d) {
                    if (d.start_mo < num_months / 2) {
                        return (d.start_mo * month_length + padding) + (d.num_months * month_length) + 40
                    } else {
                        return d.start_mo * month_length + padding - 1;
                    }
                })
                .attr('y2', function(d) {
                    var temp = currY3;
                    currY3 = currY3 + (item_length*d.time_level) + rect_padding; 
                    return temp + (d.time_level * item_length) /2;
                })
                .attr('stroke', 'grey');

            /* titles on the timeline */
            itemGroup.append('text')
                .attr('x', function(d)  {
                    if (d.start_mo < num_months / 2) {
                        return (d.start_mo * month_length + padding) + (d.num_months * month_length) + 45
                    } else {
                        return d.start_mo * month_length + padding - 45
                    }
                })
                .attr('y', function(d) {
                    var temp = currY4;             
                    currY4 = currY4 + (item_length*d.time_level) + rect_padding; 
                    return temp + (d.time_level * item_length) /2 + 5;
                })
                .attr('text-anchor', function(d) {
                    if (d.start_mo >= num_months / 2) {
                        return "end";
                    }
                })
                .attr('font-size', "18px")
                .attr('fill', 'grey')
                .text((d) => d.title);

            // what if i created the whole group relative to itself and then set the x/y of the whole group???
                // have to use transform for <g> 

                // var currY = padding;
                // svgTimeline.selectAll('line')
                // .data(data)
                // .enter()
                // .append('line')
                //     .attr('x1', (d) => (d.start_mo * month_length + padding) + (d.num_months * month_length))
                //     .attr('y1', function(d) {
                //         var temp = currY;
                //         currY = currY + (item_length*d.time_level) + rect_padding;
                //         return temp + (d.time_level * item_length) /2;
                //     })
                //     .attr('x2', (d) => (d.start_mo * month_length + padding) + (d.num_months * month_length) + 20)
                //     .attr('y2', (d) => )
                //     .attr('stroke', 'grey');

 
                // /* HANDLING MOUSE EVENTS */

                // clearSelection
                wrapper.on('click', function() {
                    clearTimelineSelection();
                });

                var item_groups = svgTimeline.selectAll('.item-group')
                    .on("mouseover", function(event, data) {
                        fadeAll();
                        highlightTimelineItem(this);
                        if (keepSelection) {
                            highlightTimelineItem(currTimelineSelection);
                            return;
                        }
                        showTimelineItemDescription(this, data);
                    })
                    .on("click", function(event, data) {
                        fadeAll();
                        d3.selectAll(".item-description").remove();
                        currTimelineSelection = this;
                        highlightTimelineItem(currTimelineSelection);
                        showTimelineItemDescription(currTimelineSelection, data);

                        keepSelection = true;
                        event.stopPropagation();
                    })

                    .on("mouseout", function() {
                        if (!keepSelection) {
                            clearTimelineSelection()
                        } else {
                            fadeAll();
                            highlightTimelineItem(currTimelineSelection);
                        }
                    });

                svgTimeline.selectAll(".item-description") // not working
                    .on('click', (event) =>console.log('clicky'))

                const x = d3.scaleTime(
                    [new Date(2015, 9, 1), new Date(2024, 12, 31)], // domain
                    [padding, w - padding]); // range

                var xAxisTop = d3.axisTop(x)
                    //.ticks(d3.timeMonth.every(6)) // num months
                    .tickSizeOuter(0)
                    .tickSizeInner(10);
                
                var xAxisBottom = d3.axisBottom(x)
                    //.ticks(d3.timeMonth.every(6)) // num months
                    .tickSizeOuter(0)
                    .tickSizeInner(10);

                //timelineContainer
                    //.append("svg")
                    // .attr("class", "axis_container")
                    // .attr("preserveAspectRatio", "xMinYMin meet")
                    // .attr("viewBox", `0 0 ${w} 50`)
                    // .style("position", "fixed") // sticky isn't working
                    // .style("bottom", 0)
                
                svgTimeline.append("g") // new group element which will contain all of our axis elements
                    .call(xAxisBottom)
                    .attr("transform", `translate(0,${rect_padding})`)
                    .attr("font-size", "20px")
                    .attr("color", "rgba(151, 151, 151, 1)")

                svgTimeline.append("g") // new group element which will contain all of our axis elements
                    .call(xAxisTop)
                    .attr("transform", `translate(0,${h-rect_padding*2})`) // put it at bottom of the canvas
                    .attr("font-size", "20px")
                    .attr("color", "rgba(151, 151, 151, 1)")
        });

        </script>
    </body>
</html>
